# AMM Math & Fixed-Point Arithmetic Review

**Date:** 2026-02-06
**Reviewer:** Claude Opus 4.6
**Scope:** solver/amm/, solver/math/, solver/safe_int.py

---

## Remediation Status

| ID | Severity | Issue | Status |
|----|----------|-------|--------|
| M1 | Moderate | `Bfp.complement()` no underflow guard | **FIXED** — Clamps to 0 when self > 1 (Python + Cython) |
| M2 | Moderate | `Bfp.sub()` allows negative results | **FIXED** — Clamps to 0 if result negative (Python + Cython) |
| M3 | Moderate | `mul_up`/`div_up` incorrect for negative Bfp | **MITIGATED** — `from_decimal()` now rejects negative input |
| L4 | Low | SafeInt accepts negative values | **DEFERRED** — By design for intermediate calculations |
| L5 | Low | No `fee_bps` bounds in UniswapV2Pool | **FIXED** — `__post_init__` validates [0, 10000) |
| L6 | Low | LimitOrderAMM floor division rounding | **DEFERRED** — 1 wei, not exploitable |
| L7 | Low | `Bfp.from_decimal` negative values | **FIXED** — Raises ValueError for negative input |
| L8 | Low | Stable math rounding drift | **DEFERRED** — Matches Solidity reference |
| L9 | Low | V3 binary search RPC calls | **DEFERRED** — Performance concern, not correctness |
| L10 | Low | Cython `BfpCy.__eq__` uses hasattr | **DEFERRED** — Cython circular import makes isinstance impractical |

---

## Overall Assessment

The AMM math implementations are faithful ports of the Solidity reference contracts. The codebase correctly uses SafeInt wrappers, applies proper rounding directions (div_up for inputs, div_down for outputs), and maintains consistency with UniswapV2, Balancer weighted/stable, and 0x limit order formulas. However, several edge cases in the fixed-point arithmetic layer could produce incorrect results.

---

## MODERATE Issues

### 1. `Bfp.complement()` has no underflow guard

**Files:** `solver/math/fixed_point.py:426`, `solver/math/fixed_point_cy.pyx:388`

```python
def complement(self) -> Bfp:
    return Bfp(self.ONE - self.value)
```

The docstring says "Requires self <= 1" but does not enforce it. If `self.value > ONE_18` (possible due to upward rounding in `pow_up`), complement produces a **negative** Bfp. This negative flows into `balance_out.mul_down(...)` in `weighted_math.py:77`, producing a negative output amount.

**Mitigation:** The result would fail the limit price check downstream, but the silent sign change is dangerous.

### 2. `Bfp.sub()` allows negative results without any guard

**File:** `solver/math/fixed_point.py:433`

Unlike `SafeInt.__sub__()` which raises `Underflow`, `Bfp.sub()` silently produces negative values. Used in critical financial calculations like `weighted_math.py:150` (`ratio = power.sub(one)`). The Solidity originals revert on underflow; this port does not.

### 3. `mul_up` and `div_up` produce incorrect results for negative Bfp

**File:** `solver/math/fixed_point.py:403-407, 416-422`

The ceiling division formula `(product - 1) // ONE + 1` assumes non-negative inputs. Python's `//` rounds toward negative infinity, so negative products produce incorrect values. The Solidity originals never encounter negatives because they use unsigned integers. This is a downstream consequence of Issues 1-2.

---

## LOW Issues

### 4. `SafeInt` accepts negative values through `__init__` and `__add__`

**File:** `solver/safe_int.py:89`

SafeInt is documented as being for "values that must remain non-negative" but `__init__` accepts any integer and `__add__` does not check results. `S(-1)` is legal and could flow into `ceiling_div`, `to_uint256`, etc. The `to_uint256()` method properly rejects negatives, but `.value` access does not.

### 5. No `fee_bps` bounds validation in UniswapV2Pool

**Files:** `solver/amm/uniswap_v2.py:38-52`, `solver/amm/uniswap_v2.py:599`

If `fee_bps >= 10000`, fee_multiplier becomes zero or negative. If negative, `get_amount_out` returns negative output. No guard exists. `parse_liquidity_to_pool` could produce fee_bps > 10000 from malformed auction data (e.g., `fee = "1.5"` yields `fee_bps = 15000`).

### 6. `LimitOrderAMM.simulate_swap` floor-divides output

**File:** `solver/amm/limit_order.py:59`

Floor division means each small swap loses up to 1 wei to rounding. Not exploitable in practice since the solver doesn't split single orders, but worth noting.

### 7. `Bfp.from_decimal` can produce negative values

**File:** `solver/math/fixed_point.py:381-387`

A negative Decimal input creates a Bfp with negative internal value. Callers currently validate inputs, but `from_decimal` itself provides no guard.

### 8. Stable math invariant calculation has minor rounding drift

**File:** `solver/amm/balancer/stable_math.py:70`

Each iterative floor division in `d_p` calculation accumulates rounding error. Consistent with Balancer Solidity reference and the 1-wei convergence check accounts for it.

### 9. V3 `max_fill_sell_order` binary search is O(log(amount)) RPC calls

**File:** `solver/amm/uniswap_v3/amm.py:233-257`

For an 18-decimal token, up to ~60 iterations with an RPC call each. Performance concern, not correctness.

### 10. Cython `BfpCy.__eq__` uses `hasattr` instead of type check

**File:** `solver/math/fixed_point_cy.pyx:401`

Uses `hasattr(other, 'value')` which matches any object with a `.value` attribute. The Python version uses `isinstance(other, Bfp)`. Could cause unexpected equality comparisons if both types coexist.

---

## Positive Observations

- SafeInt usage is thorough for cross-multiplication comparisons
- Forward verification pattern (`converge_in_amount`) correctly handles Balancer instability
- UniswapV2 constant product formula matches Solidity exactly (including ceiling `+1` in `get_amount_in`)
- Balancer weighted math correctly implements weighted product AMM with proper rounding directions
- LogExpMath port is faithful including truncation-toward-zero for negative values
- Stable math Newton-Raphson matches StableMath.sol including convergence criteria
- Fee handling (subtract before swap for sells, add after for buys) is correct
- Scale up/down operations correctly handle 18-decimal normalization

---

## Recommendations

1. **Add guard to `Bfp.complement()`** -- clamp or raise if `self.value > ONE_18`
2. **Add `fee_bps` bounds validation** -- reject `fee_bps < 0` or `fee_bps >= 10000`
3. **Consider underflow checks in `Bfp.sub()`** -- at minimum an assertion in debug mode
4. **Add input validation for negative Bfp creation** via `from_decimal` and `from_wei`
