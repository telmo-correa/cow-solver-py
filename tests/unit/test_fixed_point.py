"""Tests for Balancer Fixed Point (Bfp) math library.

Test vectors are taken directly from the Rust implementation at:
cow-services/crates/shared/src/sources/balancer_v2/swap/fixed_point/logexpmath.rs

These vectors were generated by running the original Balancer Solidity contract.
"""

from decimal import Decimal

import pytest

from solver.math.fixed_point import (
    AMP_PRECISION,
    MAX_IN_RATIO,
    MAX_OUT_RATIO,
    ONE_18,
    Bfp,
    InvalidExponent,
    ProductOutOfBounds,
    XOutOfBounds,
    YOutOfBounds,
    _ln,
    _ln_36,
    exp,
    pow_raw,
)


class TestBfpConstruction:
    """Tests for Bfp construction methods."""

    def test_from_wei(self) -> None:
        """Create Bfp from raw wei value."""
        bfp = Bfp.from_wei(1_500_000_000_000_000_000)
        assert bfp.value == 1_500_000_000_000_000_000

    def test_from_decimal(self) -> None:
        """Create Bfp from Decimal."""
        bfp = Bfp.from_decimal(Decimal("1.5"))
        assert bfp.value == 1_500_000_000_000_000_000

    def test_from_int(self) -> None:
        """Create Bfp from integer."""
        bfp = Bfp.from_int(3)
        assert bfp.value == 3 * 10**18

    def test_to_decimal(self) -> None:
        """Convert Bfp to Decimal."""
        bfp = Bfp.from_wei(1_500_000_000_000_000_000)
        assert bfp.to_decimal() == Decimal("1.5")


class TestBfpArithmetic:
    """Tests for basic arithmetic operations."""

    def test_add(self) -> None:
        """Add two Bfp values."""
        a = Bfp.from_decimal(Decimal("1.5"))
        b = Bfp.from_decimal(Decimal("2.5"))
        result = a.add(b)
        assert result.to_decimal() == Decimal("4.0")

    def test_sub(self) -> None:
        """Subtract Bfp values."""
        a = Bfp.from_decimal(Decimal("3.5"))
        b = Bfp.from_decimal(Decimal("1.5"))
        result = a.sub(b)
        assert result.to_decimal() == Decimal("2.0")

    def test_mul_down_rounds_down(self) -> None:
        """Multiplication rounds down."""
        a = Bfp.from_wei(1_000_000_000_000_000_001)
        b = Bfp.from_int(3)
        result = a.mul_down(b)
        assert result.value == 3_000_000_000_000_000_003

    def test_mul_up_rounds_up(self) -> None:
        """Multiplication rounds up."""
        a = Bfp.from_wei(1)
        b = Bfp.from_wei(1)
        result = a.mul_up(b)
        assert result.value == 1

    def test_mul_up_zero(self) -> None:
        """Multiplication by zero returns zero."""
        a = Bfp.from_wei(0)
        b = Bfp.from_int(100)
        result = a.mul_up(b)
        assert result.value == 0

    def test_div_down_rounds_down(self) -> None:
        """Division rounds down."""
        a = Bfp.from_int(10)
        b = Bfp.from_int(3)
        result = a.div_down(b)
        expected = 3_333_333_333_333_333_333
        assert result.value == expected

    def test_div_up_rounds_up(self) -> None:
        """Division rounds up."""
        a = Bfp.from_int(10)
        b = Bfp.from_int(3)
        result = a.div_up(b)
        expected = 3_333_333_333_333_333_334
        assert result.value == expected

    def test_div_by_zero_raises(self) -> None:
        """Division by zero raises ZeroDivisionError."""
        a = Bfp.from_int(10)
        b = Bfp.from_wei(0)
        with pytest.raises(ZeroDivisionError):
            a.div_down(b)

    def test_div_up_by_zero_raises(self) -> None:
        """Division by zero raises ZeroDivisionError."""
        a = Bfp.from_int(10)
        b = Bfp.from_wei(0)
        with pytest.raises(ZeroDivisionError):
            a.div_up(b)

    def test_complement(self) -> None:
        """Complement returns 1 - self."""
        a = Bfp.from_decimal(Decimal("0.3"))
        result = a.complement()
        assert result.to_decimal() == Decimal("0.7")

    def test_complement_of_half(self) -> None:
        """Complement of 0.5 is 0.5."""
        a = Bfp.from_decimal(Decimal("0.5"))
        result = a.complement()
        assert result.to_decimal() == Decimal("0.5")


class TestBfpComparison:
    """Tests for comparison operations."""

    def test_eq(self) -> None:
        a = Bfp.from_int(5)
        b = Bfp.from_int(5)
        assert a == b

    def test_lt(self) -> None:
        a = Bfp.from_int(3)
        b = Bfp.from_int(5)
        assert a < b

    def test_le(self) -> None:
        a = Bfp.from_int(5)
        b = Bfp.from_int(5)
        assert a <= b

    def test_gt(self) -> None:
        a = Bfp.from_int(7)
        b = Bfp.from_int(3)
        assert a > b

    def test_ge(self) -> None:
        a = Bfp.from_int(5)
        b = Bfp.from_int(5)
        assert a >= b


class TestLnFunction:
    """Tests for _ln() using Rust/Solidity test vectors."""

    # Test vectors from Rust: generated with Balancer contract
    # await generateOk("_ln", input)
    @pytest.mark.parametrize(
        "input_val,expected",
        [
            (1, -41446531673892822312),
            (100, -36841361487904730944),
            (1000000, -27631021115928548208),
            (100000000000, -16118095650958319788),
            (1000000000000000000, 0),  # ln(1) = 0
            (100000000000000000000000, 11512925464970228420),
            (100000000000000000000000000000, 25328436022934502524),
            (100000000000000000000000000000000000, 39143946580898776628),
            (100000000000000000000000000000000000000000, 52959457138863050732),
            (
                100000000000000000000000000000000000000000000000000000000000000000,
                108221499370720147148,
            ),
            (
                10000000000000000000000000000000000000000000000000000000000000000000000000000,
                133549935393654649672,
            ),
        ],
    )
    def test_ln_matches_rust(self, input_val: int, expected: int) -> None:
        """Test _ln matches Rust/Solidity output exactly."""
        result = _ln(input_val)
        assert result == expected


class TestLn36Function:
    """Tests for _ln_36() using Rust/Solidity test vectors."""

    # Test vectors from Rust: generated with Balancer contract
    @pytest.mark.parametrize(
        "input_val,expected",
        [
            (900000000000000000, -105360515657826301227479460574005190),  # LN_36_LOWER_BOUND
            (950000000000000000, -51293294387550533426196144149312054),
            (999999999999999999, -1000000000000000000),
            (1000000000000000000, 0),  # ln(1) = 0
            (1000000000000000001, 999999999999999998),
            (1050000000000000000, 48790164169432003065374404178136230),
            (1100000000000000000, 95310179804324860043948199225536944),  # LN_36_UPPER_BOUND
        ],
    )
    def test_ln_36_matches_rust(self, input_val: int, expected: int) -> None:
        """Test _ln_36 matches Rust/Solidity output exactly."""
        result = _ln_36(input_val)
        assert result == expected


class TestExpFunction:
    """Tests for exp() using Rust/Solidity test vectors."""

    # Test vectors from Rust: generated with Balancer contract
    @pytest.mark.parametrize(
        "input_val,expected",
        [
            (-41000000000000000000, 1),  # MIN_NATURAL_EXPONENT -> ~0
            (-10000000000000000000, 45399929762484),
            (-1000000000000000000, 367879441171442321),  # e^-1
            (-100000000, 999999999900000000),
            (-1, 999999999999999999),
            (0, 1000000000000000000),  # e^0 = 1
            (1, 1000000000000000001),
            (100000000, 1000000000100000000),
            (999999999999999999, 2718281828459045227),
            (1000000000000000000, 2718281828459045235),  # e^1 = e
            (1000000000000000001, 2718281828459045238),
            (10000000000000000000, 22026465794806716516930),
            (
                100000000000000000000,
                26881171418161354484131967259153438289195652545281114830700000,
            ),
            (
                130000000000000000000,  # MAX_NATURAL_EXPONENT
                287264955081783193326519143742863858051506000000000000000000000000000000000,
            ),
        ],
    )
    def test_exp_matches_rust(self, input_val: int, expected: int) -> None:
        """Test exp matches Rust/Solidity output exactly."""
        result = exp(input_val)
        assert result == expected

    def test_exp_below_min_raises(self) -> None:
        """exp() raises for exponent below MIN_NATURAL_EXPONENT."""
        with pytest.raises(InvalidExponent):
            exp(-41000000000000000001)

    def test_exp_above_max_raises(self) -> None:
        """exp() raises for exponent above MAX_NATURAL_EXPONENT."""
        with pytest.raises(InvalidExponent):
            exp(130000000000000000001)


class TestPowRawFunction:
    """Tests for pow_raw() using Rust/Solidity test vectors."""

    # Success test vectors from Rust
    @pytest.mark.parametrize(
        "x,y,expected",
        [
            # I256::MAX as base, exponent 1
            (
                57896044618658097711785492504343953926634992332820282019728792003956564819967,
                1,
                1000000000000000135,
            ),
            # Base 1, exponent MILD_EXPONENT_BOUND - 1
            (
                1000000000000000000,
                289480223093290488558927462521719769633174961664101410097,
                1000000000000000000,
            ),
            # Large base close to exp(MAX_NATURAL_EXPONENT)
            (
                287200000000000000000000000000000000000000000000000000000000000000000000000,
                1000000000000000000,
                287199999999999999375313920267432160096964000000000000000000000000000000000,
            ),
            # Small base with exponent 2
            (1250152867, 2000000000000000000, 1),
            # 0^large
            (0, 1000000000000000000000, 0),
            # 0^0 = 1
            (0, 0, 1000000000000000000),
            # 1^0 = 1
            (1000000000000000000, 0, 1000000000000000000),
            # 2^2 = 4
            (2000000000000000000, 2000000000000000000, 3999999999999999996),
        ],
    )
    def test_pow_raw_matches_rust(self, x: int, y: int, expected: int) -> None:
        """Test pow_raw matches Rust/Solidity output exactly."""
        result = pow_raw(x, y)
        assert result == expected

    def test_pow_raw_x_out_of_bounds(self) -> None:
        """pow_raw raises XOutOfBounds for base > I256::MAX."""
        with pytest.raises(XOutOfBounds):
            pow_raw(
                57896044618658097711785492504343953926634992332820282019728792003956564819968,
                1,
            )

    def test_pow_raw_y_out_of_bounds(self) -> None:
        """pow_raw raises YOutOfBounds for exponent >= MILD_EXPONENT_BOUND."""
        with pytest.raises(YOutOfBounds):
            pow_raw(
                1000000000000000000,
                289480223093290488558927462521719769633174961664101410098,
            )

    def test_pow_raw_product_out_of_bounds_large_base(self) -> None:
        """pow_raw raises ProductOutOfBounds when y * ln(x) is too large."""
        with pytest.raises(ProductOutOfBounds):
            pow_raw(
                287300000000000000000000000000000000000000000000000000000000000000000000000,
                1000000000000000000,
            )

    def test_pow_raw_product_out_of_bounds_small_base(self) -> None:
        """pow_raw raises ProductOutOfBounds when y * ln(x) is too negative."""
        with pytest.raises(ProductOutOfBounds):
            pow_raw(1250152866, 2000000000000000000)


class TestBfpPower:
    """Tests for Bfp pow_up and pow_down methods."""

    def test_pow_exponent_zero(self) -> None:
        """x^0 = 1 for any x."""
        base = Bfp.from_int(5)
        exp = Bfp.from_wei(0)
        result = base.pow_up(exp)
        # pow_raw returns ONE_18, then add max_error
        expected = ONE_18 + (ONE_18 * 10000 // ONE_18 + 1)
        assert result.value == expected

    def test_pow_base_zero(self) -> None:
        """0^x = 0 for any positive x."""
        base = Bfp.from_wei(0)
        exp_val = Bfp.from_int(2)
        result = base.pow_up(exp_val)
        # pow_raw returns 0, max_error = 0 * ... + 1 = 1
        assert result.value == 1

    def test_pow_2_squared(self) -> None:
        """2^2 = 4 (with error bounds)."""
        base = Bfp.from_int(2)
        exp_val = Bfp.from_int(2)
        # From Rust test vector: pow(2e18, 2e18) = 3999999999999999996
        # pow_up adds error: 3999999999999999996 * 10000 / 10^18 + 1 = 40
        result = base.pow_up(exp_val)
        expected_raw = 3999999999999999996
        max_error = expected_raw * 10000 // ONE_18 + 1
        assert result.value == expected_raw + max_error

    def test_pow_down_less_than_pow_up(self) -> None:
        """pow_down should return less than pow_up."""
        base = Bfp.from_decimal(Decimal("1.5"))
        exp_val = Bfp.from_decimal(Decimal("2.5"))
        down = base.pow_down(exp_val)
        up = base.pow_up(exp_val)
        assert down.value < up.value


class TestConstants:
    """Tests for module constants."""

    def test_max_in_ratio(self) -> None:
        """MAX_IN_RATIO is 0.3 (30%)."""
        assert MAX_IN_RATIO.to_decimal() == Decimal("0.3")

    def test_max_out_ratio(self) -> None:
        """MAX_OUT_RATIO is 0.3 (30%)."""
        assert MAX_OUT_RATIO.to_decimal() == Decimal("0.3")

    def test_amp_precision(self) -> None:
        """AMP_PRECISION is 1000."""
        assert AMP_PRECISION == 1000


class TestBfpRepresentation:
    """Tests for string representation."""

    def test_repr(self) -> None:
        bfp = Bfp.from_wei(12345)
        assert repr(bfp) == "Bfp(12345)"

    def test_str(self) -> None:
        bfp = Bfp.from_decimal(Decimal("1.5"))
        assert str(bfp) == "1.5"


class TestBfpPrecision:
    """Tests for precision edge cases."""

    def test_very_small_multiplication(self) -> None:
        """Test multiplication of very small values."""
        a = Bfp.from_decimal(Decimal("0.000001"))
        b = Bfp.from_decimal(Decimal("0.000001"))
        result = a.mul_down(b)
        expected = Bfp.from_decimal(Decimal("0.000000000001"))
        assert result.value == expected.value

    def test_large_values(self) -> None:
        """Test with large values."""
        a = Bfp.from_int(1_000_000)
        b = Bfp.from_int(1_000_000)
        result = a.mul_down(b)
        expected = 10**12 * 10**18
        assert result.value == expected

    def test_div_precision(self) -> None:
        """Division maintains precision."""
        a = Bfp.from_int(1)
        b = Bfp.from_int(3)
        result = a.div_down(b)
        assert len(str(result.value)) >= 18
